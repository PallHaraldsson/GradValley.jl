<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · GradValley.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="GradValley.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="GradValley.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GradValley.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#GradValley"><span>GradValley</span></a></li><li><a class="tocitem" href="#GradValley.Layers"><span>GradValley.Layers</span></a></li><li><a class="tocitem" href="#GradValley.Optimization"><span>GradValley.Optimization</span></a></li><li><a class="tocitem" href="#GradValley.Functional"><span>GradValley.Functional</span></a></li></ul></li><li><a class="tocitem" href="../tutorials_and_examples/">Tutorials and Examples</a></li><li><a class="tocitem" href="../(pre-trained)_models/">(Pre-Trained) Models</a></li><li><a class="tocitem" href="../learning/">Learning</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jonas208/GradValley.jl/blob/main/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>For many layers and functions, the documentation is still missing because this documentation is still under construction!</p></div></div><ul><li><a href="#Reference">Reference</a></li><li class="no-marker"><ul><li><a href="#GradValley">GradValley</a></li><li><a href="#GradValley.Layers">GradValley.Layers</a></li><li class="no-marker"><ul><li><a href="#Convolution">Convolution</a></li><li><a href="#Pooling">Pooling</a></li></ul></li><li><a href="#GradValley.Optimization">GradValley.Optimization</a></li><li><a href="#GradValley.Functional">GradValley.Functional</a></li></ul></li></ul><h2 id="GradValley"><a class="docs-heading-anchor" href="#GradValley">GradValley</a><a id="GradValley-1"></a><a class="docs-heading-anchor-permalink" href="#GradValley" title="Permalink"></a></h2><h2 id="GradValley.Layers"><a class="docs-heading-anchor" href="#GradValley.Layers">GradValley.Layers</a><a id="GradValley.Layers-1"></a><a class="docs-heading-anchor-permalink" href="#GradValley.Layers" title="Permalink"></a></h2><h3 id="Convolution"><a class="docs-heading-anchor" href="#Convolution">Convolution</a><a id="Convolution-1"></a><a class="docs-heading-anchor-permalink" href="#Convolution" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GradValley.Layers.Conv" href="#GradValley.Layers.Conv"><code>GradValley.Layers.Conv</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Conv(in_channels::Int, out_channels::Int, kernel_size::Tuple{Int, Int}; stride::Tuple{Int, Int}=(1, 1), padding::Tuple{Int, Int}=(0, 0), dilation::Tuple{Int, Int}=(1, 1), groups::Int=1, activation_function::Union{Nothing, String}=nothing, init_mode::String=&quot;default_uniform&quot;, use_bias::Bool=true)</code></pre><p>A convolution layer. Apply a 2D convolution over an input signal with additional batch and channel dimensions. This layer currently (!) only accepts Float64 array inputs. </p><p><strong>Arguments</strong></p><ul><li><code>in_channels::Int</code>: the number of channels in the input image</li><li><code>out_channels::Int</code>: the number of channels produced by the convolution</li><li><code>kernel_size::Tuple{Int, Int}</code>: the size of the convolving kernel</li><li><code>stride::Tuple{Int, Int}=(1, 1)</code>: the stride of the convolution</li><li><code>padding::Tuple{Int, Int}=(0, 0)</code>: the zero padding added to all four sides of the input</li><li><code>dilation::Tuple{Int, Int}=(1, 1)</code>: the spacing between kernel elements</li><li><code>groups::Int=1</code>: the number of blocked connections from input channels to output channels (in-channels and out-channels must both be divisible by groups)</li><li><code>activation_function::Union{Nothing, String}=nothing</code>: the element-wise activation function which will be applied to the output after the convolution </li><li><code>init_mode::String=&quot;default_uniform&quot;</code>: the initialization mode of the weights   (can be <code>&quot;default_uniform&quot;</code>, <code>&quot;default&quot;</code>, <code>&quot;kaiming_uniform&quot;</code>, <code>&quot;kaiming&quot;</code>, <code>&quot;xavier_uniform&quot;</code> or <code>&quot;xavier&quot;</code>)</li><li><code>use_bias::Bool=true</code>: if true, adds a learnable bias to the output</li></ul><p><strong>Shapes</strong></p><ul><li>Input: <span>$(N, C_{in}, H_{in}, W_{in})$</span></li><li>Weight: <span>$(C_{out}, \frac{C_{in}}{groups}, H_{w}, W_{w})$</span></li><li>Bias: <span>$(C_{out}, )$</span></li><li>Output: <span>$(N, C_{out}, H_{out}, W_{out})$</span>, where <ul><li><span>$H_{out} = {\frac{H_{in} + 2 \cdot padding[1] - dilation[1] \cdot (H_w - 1)}{stride[1]}} + 1$</span></li><li><span>$W_{out} = {\frac{W_{in} + 2 \cdot padding[2] - dilation[2] \cdot (W_w - 1)}{stride[2]}} + 1$</span></li></ul></li></ul><p><strong>Useful Fields/Variables</strong></p><ul><li><code>kernels::Array{Float64, 4}</code>: the learnable weights of the layer</li><li><code>bias::Vector{Float64}</code>: the learnable bias of the layer (used when <code>use_bias=true</code>)</li><li><code>gradients::Array{Float64, 4}</code>: the current gradients of the weights/kernels</li><li><code>bias_gradients::Vector{Float64}</code>: the current gradients of the bias</li></ul><p><strong>Definition</strong></p><p>For one group, a multichannel 2D convolution (disregarding batch dimension and activation function) can be described as:</p><ul><li><span>$o_{c_{out}, y_{out}, x_{out}} = \big(\sum_{c_{in=1}}^{C_{in}}\sum_{y_w=1}^{H_{w}}\sum_{x_w=1}^{W_{w}} i_{c_{in}, y_{in}, x_{in}} \cdot w_{c_{out}, c_{in}, y_w, x_w}\big) + b_{c_{out}}$</span>, where<ul><li><span>$y_{in} = y_{out} + (stride[1] - 1) \cdot (y_{out} - 1) + (y_w - 1) \cdot dilation[1]$</span></li><li><span>$x_{in} = x_{out} + (stride[2] - 1) \cdot (x_{out} - 1) + (x_w - 1) \cdot dilation[2]$</span></li></ul></li></ul><p><em>O</em> is the output array, <em>I</em> the input array, <em>W</em> the weight array and <em>B</em> the bias array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># square kernels and fully default values of keyword arguments
julia&gt; m = Conv(3, 6, (5, 5))
# non-square kernels and unequal stride and with padding as well as specified weight initialization mode
# (init_mode=&quot;kaiming&quot; stands for kaiming weight initialization with normally distributed values)
julia&gt; m = Conv(3, 6, (3, 5), stride=(2, 1), padding=(2, 1))
# non-square kernels and unequal stride and with padding, dilation and 3 groups
# (because groups=in_channels and out_channles is divisible by groups, it is even a depthwise convolution)
julia&gt; m = Conv(3, 6, (3, 5), stride=(2, 1), padding=(4, 2), dilation=(3, 1), groups=3)
# computing the output of the layer (with random inputs)
julia&gt; input = rand(32, 3, 50, 50)
julia&gt; output = forward(m, input)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jonas208/GradValley.jl/blob/ce41910cb2db1288b13965665e92aaf70e2c5584/src/gv_layers.jl#L181-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradValley.Layers.DepthwiseConv" href="#GradValley.Layers.DepthwiseConv"><code>GradValley.Layers.DepthwiseConv</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DepthwiseConv(in_channels::Int, out_channels::Int, kernel_size::Tuple{Int, Int}; stride::Tuple{Int, Int}=(1, 1), padding::Tuple{Int, Int}=(0, 0), dilation::Tuple{Int, Int}=(1, 1), activation_function::Union{Nothing, String}=nothing, init_mode::String=&quot;default_uniform&quot;, use_bias::Bool=true)</code></pre><p>A depthwise convolution layer. Apply a 2D depthwise convolution over an input signal with additional batch and channel dimensions. This layer currently (!) only accepts Float64 array inputs. </p><p><strong>Arguments</strong></p><ul><li><code>in_channels::Int</code>: the number of channels in the input image</li><li><code>out_channels::Int</code>: the number of channels produced by the convolution</li><li><code>kernel_size::Tuple{Int, Int}</code>: the size of the convolving kernel</li><li><code>stride::Tuple{Int, Int}=(1, 1)</code>: the stride of the convolution</li><li><code>padding::Tuple{Int, Int}=(0, 0)</code>: the zero padding added to all four sides of the input</li><li><code>dilation::Tuple{Int, Int}=(1, 1)</code>: the spacing between kernel elements</li><li><code>activation_function::Union{Nothing, String}=nothing</code>: the element-wise activation function which will be applied to the output after the convolution </li><li><code>init_mode::String=&quot;default_uniform&quot;</code>: the initialization mode of the weights   (can be <code>&quot;default_uniform&quot;</code>, <code>&quot;default&quot;</code>, <code>&quot;kaiming_uniform&quot;</code>, <code>&quot;kaiming&quot;</code>, <code>&quot;xavier_uniform&quot;</code> or <code>&quot;xavier&quot;</code>)</li><li><code>use_bias::Bool=true</code>: if true, adds a learnable bias to the output</li></ul><p><strong>Shapes</strong></p><ul><li>Input: <span>$(N, C_{in}, H_{in}, W_{in})$</span></li><li>Weight: <span>$(C_{out}, \frac{C_{in}}{groups}, H_{w}, W_{w})$</span>, where <span>$groups = in\_channels$</span></li><li>Bias: <span>$(C_{out}, )$</span></li><li>Output: <span>$(N, C_{out}, H_{out}, W_{out})$</span>, where <ul><li><span>$H_{out} = {\frac{H_{in} + 2 \cdot padding[1] - dilation[1] \cdot (H_w - 1)}{stride[1]}} + 1$</span></li><li><span>$W_{out} = {\frac{W_{in} + 2 \cdot padding[2] - dilation[2] \cdot (W_w - 1)}{stride[2]}} + 1$</span></li></ul></li></ul><p><strong>Useful Fields/Variables</strong></p><ul><li><code>kernels::Array{Float64, 4}</code>: the learnable weights of the layer</li><li><code>bias::Vector{Float64}</code>: the learnable bias of the layer (used when <code>use_bias=true</code>)</li><li><code>gradients::Array{Float64, 4}</code>: the current gradients of the weights/kernels</li><li><code>bias_gradients::Vector{Float64}</code>: the current gradients of the bias</li></ul><p><strong>Definition</strong></p><p>A convolution is called depthwise if <span>$groups=in\_channels$</span> and <span>$out\_channels=k \cdot in\_channels$</span>, where <span>$k$</span> is a positive integer. The second condition ensures that the of number out-channels is divisible by the number of groups/in-channels. In the background, the standard convolution operation is also used for this layer.  It is just an interface making clear that this layer can only perform a depthwise convolution.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># square kernels and fully default values of keyword arguments
julia&gt; m = DepthwiseConv(3, 6, (5, 5))
# non-square kernels and unequal stride and with padding as well as specified weight initialization mode
# (init_mode=&quot;kaiming&quot; stands for kaiming weight initialization with normally distributed values)
julia&gt; m = DepthwiseConv(3, 6, (3, 5), stride=(2, 1), padding=(2, 1))
# non-square kernels and unequal stride and with padding, dilation and 3 groups
# (because groups=in_channels and out_channles is divisible by groups, it is even a depthwise convolution)
julia&gt; m = DepthwiseConv(3, 6, (3, 5), stride=(2, 1), padding=(4, 2), dilation=(3, 1), groups=3)
# computing the output of the layer (with random inputs)
julia&gt; input = rand(32, 3, 50, 50)
julia&gt; output = forward(m, input)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jonas208/GradValley.jl/blob/ce41910cb2db1288b13965665e92aaf70e2c5584/src/gv_layers.jl#L309-L361">source</a></section></article><h3 id="Pooling"><a class="docs-heading-anchor" href="#Pooling">Pooling</a><a id="Pooling-1"></a><a class="docs-heading-anchor-permalink" href="#Pooling" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GradValley.Layers.MaxPool" href="#GradValley.Layers.MaxPool"><code>GradValley.Layers.MaxPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MaxPool(kernel_size::Tuple{Int, Int}; stride::Tuple{Int, Int}=kernel_size, padding::Tuple{Int, Int}=(0, 0), dilation::Tuple{Int, Int}=(1, 1), activation_function::Union{Nothing, String}=nothing)</code></pre><p>A maximum pooling layer. Apply a 2D maximum pooling over an input signal with additional batch and channel dimensions. This layer currently (!) only accepts Float64 array inputs. </p><p><strong>Arguments</strong></p><ul><li><code>kernel_size::Tuple{Int, Int}</code>: the size of the window to take the maximum over</li><li><code>stride::Tuple{Int, Int}=kernel_size</code>: the stride of the window</li><li><code>padding::Tuple{Int, Int}=(0, 0)</code>: the zero padding added to all four sides of the input</li><li><code>dilation::Tuple{Int, Int}=(1, 1)</code>: the spacing between the window elements</li><li><code>activation_function::Union{Nothing, String}=nothing</code>: the element-wise activation function which will be applied to the output after the pooling</li></ul><p><strong>Shapes</strong></p><ul><li>Input: <span>$(N, C, H_{in}, W_{in})$</span></li><li>Output: <span>$(N, C, H_{out}, W_{out})$</span>, where <ul><li><span>$H_{out} = {\frac{H_{in} + 2 \cdot padding[1] - dilation[1] \cdot (kernel\_size[1] - 1)}{stride[1]}} + 1$</span></li><li><span>$W_{out} = {\frac{W_{in} + 2 \cdot padding[2] - dilation[2] \cdot (kernel\_size[2] - 1)}{stride[2]}} + 1$</span></li></ul></li></ul><p><strong>Definition</strong></p><p>A multichannel 2D maximum pooling (disregarding batch dimension and activation function) can be described as:</p><p class="math-container">\[\begin{align*}
o_{c, y_{out}, x_{out}} = \max
_{y_w = 1, ..., kernel\_size[1] \ x_w = 1, ..., kernel\_size[2]}
i_{c, y_{in}, x_{in}}
\end{align*}\]</p><p>Where</p><ul><li><span>$y_{in} = y_{out} + (stride[1] - 1) \cdot (y_{out} - 1) + (y_w - 1) \cdot dilation[1]$</span></li><li><span>$x_{in} = x_{out} + (stride[2] - 1) \cdot (x_{out} - 1) + (x_w - 1) \cdot dilation[2]$</span></li></ul><p><em>O</em> is the output array and <em>I</em> the input array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># pooling of square window of size=(3, 3) and automatically selected stride
julia&gt; m = MaxPool((3, 3))
# pooling of non-square window with custom stride and padding
julia&gt; m = MaxPool((3, 2), stride=(2, 1), padding=(1, 1))
# computing the output of the layer (with random inputs)
julia&gt; input = rand(32, 3, 50, 50)
julia&gt; output = forward(m, input)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jonas208/GradValley.jl/blob/ce41910cb2db1288b13965665e92aaf70e2c5584/src/gv_layers.jl#L706-L749">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradValley.Layers.AvgPool" href="#GradValley.Layers.AvgPool"><code>GradValley.Layers.AvgPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AvgPool(kernel_size::Tuple{Int, Int}; stride::Tuple{Int, Int}=kernel_size, padding::Tuple{Int, Int}=(0, 0), dilation::Tuple{Int, Int}=(1, 1), activation_function::Union{Nothing, String}=nothing)</code></pre><p>An average pooling layer. Apply a 2D average pooling over an input signal with additional batch and channel dimensions. This layer currently (!) only accepts Float64 array inputs. </p><p><strong>Arguments</strong></p><ul><li><code>kernel_size::Tuple{Int, Int}</code>: the size of the window to take the average over</li><li><code>stride::Tuple{Int, Int}=kernel_size</code>: the stride of the window</li><li><code>padding::Tuple{Int, Int}=(0, 0)</code>: the zero padding added to all four sides of the input</li><li><code>dilation::Tuple{Int, Int}=(1, 1)</code>: the spacing between the window elements</li><li><code>activation_function::Union{Nothing, String}=nothing</code>: the element-wise activation function which will be applied to the output after the pooling</li></ul><p><strong>Shapes</strong></p><ul><li>Input: <span>$(N, C, H_{in}, W_{in})$</span></li><li>Output: <span>$(N, C, H_{out}, W_{out})$</span>, where <ul><li><span>$H_{out} = {\frac{H_{in} + 2 \cdot padding[1] - dilation[1] \cdot (kernel\_size[1] - 1)}{stride[1]}} + 1$</span></li><li><span>$W_{out} = {\frac{W_{in} + 2 \cdot padding[2] - dilation[2] \cdot (kernel\_size[2] - 1)}{stride[2]}} + 1$</span></li></ul></li></ul><p><strong>Definition</strong></p><p>A multichannel 2D average pooling (disregarding batch dimension and activation function) can be described as:</p><ul><li><span>$o_{c, y_{out}, x_{out}} = \frac{1}{kernel\_size[1] \cdot kernel\_size[2]} \sum_{i=1}^{kernel\_size[1]}\sum_{j=1}^{kernel\_size[2]} i_{c, y_{in}, x_{in}}$</span>, where<ul><li><span>$y_{in} = y_{out} + (stride[1] - 1) \cdot (y_{out} - 1) + (y_w - 1) \cdot dilation[1]$</span></li><li><span>$x_{in} = x_{out} + (stride[2] - 1) \cdot (x_{out} - 1) + (x_w - 1) \cdot dilation[2]$</span></li></ul></li></ul><p><em>O</em> is the output array and <em>I</em> the input array.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># pooling of square window of size=(3, 3) and automatically selected stride
julia&gt; m = AvgPool((3, 3))
# pooling of non-square window with custom stride and padding
julia&gt; m = AvgPool((3, 2), stride=(2, 1), padding=(1, 1))
# computing the output of the layer (with random inputs)
julia&gt; input = rand(32, 3, 50, 50)
julia&gt; output = forward(m, input)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jonas208/GradValley.jl/blob/ce41910cb2db1288b13965665e92aaf70e2c5584/src/gv_layers.jl#L848-L884">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradValley.Layers.AdaptiveMaxPool" href="#GradValley.Layers.AdaptiveMaxPool"><code>GradValley.Layers.AdaptiveMaxPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AdaptiveMaxPool(output_size::Tuple{Int, Int}; activation_function::Union{Nothing, String}=nothing)</code></pre><p>An adaptive maximum pooling layer. Apply a 2D adaptive maximum pooling over an input signal with additional batch and channel dimensions. For any input size, the size of the output is always equal to the specified <span>$output\_size$</span>. This layer currently (!) only accepts Float64 array inputs. </p><p><strong>Arguments</strong></p><ul><li><code>output_size::Tuple{Int, Int}</code>: the target output size of the image (can even be larger than the input size) of the form <span>$(H_{out}, W_{out})$</span></li><li><code>activation_function::Union{Nothing, String}=nothing</code>: the element-wise activation function which will be applied to the output after the pooling</li></ul><p><strong>Shapes</strong></p><ul><li>Input: <span>$(N, C, H_{in}, W_{in})$</span></li><li>Output: <span>$(N, C, H_{out}, W_{out})$</span>, where <span>$(H_{out}, W_{out}) = output\_size$</span></li></ul><p><strong>Definition</strong></p><p>In some cases, the kernel-size and stride could be calculated in a way that the output would have the target size  (using a standard maximum pooling with the calculated kernel-size and stride, padding and dilation would not  be used in this case). However, this approach would only work if the input size is an integer multiple of the output size (See this question at stack overflow for further information: <a href="https://stackoverflow.com/questions/53841509/how-does-adaptive-pooling-in-pytorch-work">stackoverflow.com/questions/53841509/how-does-adaptive-pooling-in-pytorch-work</a>). A more generic approach is to calculate the indices of the input with an additional algorithm only for adaptive pooling.  With this approach, it is even possible that the output is larger than the input what is really unusual for pooling simply because that is the opposite of what pooling actually should do, namely reducing the size. The <code>function get_in_indices(in_len, out_len)</code> in  <a href="https://github.com/jonas208/GradValley.jl/blob/main/src/gv_functional.jl"><code>gv_functional.jl</code></a> (line 95 - 113) implements such an algorithm (similar to the one at the stack overflow question), so you could check there on how exactly it is defined. Thus, the mathematical definition would be identical to the one at <a href="#GradValley.Layers.MaxPool"><code>MaxPool</code></a> with the difference that the indices <span>$y_{in}$</span> and <span>$x_{in}$</span>  have already been calculated beforehand.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># target output size of 5x5
julia&gt; m = AdaptiveMaxPool((5, 5))
# computing the output of the layer (with random inputs)
julia&gt; input = rand(32, 3, 50, 50)
julia&gt; output = forward(m, input)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jonas208/GradValley.jl/blob/ce41910cb2db1288b13965665e92aaf70e2c5584/src/gv_layers.jl#L983-L1019">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GradValley.Layers.AdaptiveAvgPool" href="#GradValley.Layers.AdaptiveAvgPool"><code>GradValley.Layers.AdaptiveAvgPool</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AdaptiveAvgPool(output_size::Tuple{Int, Int}; activation_function::Union{Nothing, String}=nothing)</code></pre><p>An adaptive average pooling layer. Apply a 2D adaptive average pooling over an input signal with additional batch and channel dimensions. For any input size, the size of the output is always equal to the specified <span>$output\_size$</span>. This layer currently (!) only accepts Float64 array inputs. </p><p><strong>Arguments</strong></p><ul><li><code>output_size::Tuple{Int, Int}</code>: the target output size of the image (can even be larger than the input size) of the form <span>$(H_{out}, W_{out})$</span></li><li><code>activation_function::Union{Nothing, String}=nothing</code>: the element-wise activation function which will be applied to the output after the pooling</li></ul><p><strong>Shapes</strong></p><ul><li>Input: <span>$(N, C, H_{in}, W_{in})$</span></li><li>Output: <span>$(N, C, H_{out}, W_{out})$</span>, where <span>$(H_{out}, W_{out}) = output\_size$</span></li></ul><p><strong>Definition</strong></p><p>In some cases, the kernel-size and stride could be calculated in a way that the output would have the target size  (using a standard average pooling with the calculated kernel-size and stride, padding and dilation would not  be used in this case). However, this approach would only work if the input size is an integer multiple of the output size (See this question at stack overflow for further information: <a href="https://stackoverflow.com/questions/53841509/how-does-adaptive-pooling-in-pytorch-work">stackoverflow.com/questions/53841509/how-does-adaptive-pooling-in-pytorch-work</a>). A more generic approach is to calculate the indices of the input with an additional algorithm only for adaptive pooling.  With this approach, it is even possible that the output is larger than the input what is really unusual for pooling simply because that is the opposite of what pooling actually should do, namely reducing the size. The <code>function get_in_indices(in_len, out_len)</code> in  <a href="https://github.com/jonas208/GradValley.jl/blob/main/src/gv_functional.jl"><code>gv_functional.jl</code></a> (line 95 - 113) implements such an algorithm (similar to the one at the stack overflow question), so you could check there on how exactly it is defined. Thus, the mathematical definition would be identical to the one at <a href="#GradValley.Layers.AvgPool"><code>AvgPool</code></a> with the difference that the indices <span>$y_{in}$</span> and <span>$x_{in}$</span>  have already been calculated beforehand.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs"># target output size of 5x5
julia&gt; m = AdaptiveAvgPool((5, 5))
# computing the output of the layer (with random inputs)
julia&gt; input = rand(32, 3, 50, 50)
julia&gt; output = forward(m, input)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jonas208/GradValley.jl/blob/ce41910cb2db1288b13965665e92aaf70e2c5584/src/gv_layers.jl#L1100-L1136">source</a></section></article><h2 id="GradValley.Optimization"><a class="docs-heading-anchor" href="#GradValley.Optimization">GradValley.Optimization</a><a id="GradValley.Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#GradValley.Optimization" title="Permalink"></a></h2><h2 id="GradValley.Functional"><a class="docs-heading-anchor" href="#GradValley.Functional">GradValley.Functional</a><a id="GradValley.Functional-1"></a><a class="docs-heading-anchor-permalink" href="#GradValley.Functional" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../getting_started/">« Getting Started</a><a class="docs-footer-nextpage" href="../tutorials_and_examples/">Tutorials and Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 16 March 2023 16:47">Thursday 16 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
