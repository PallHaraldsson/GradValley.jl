var documenterSearchIndex = {"docs":
[{"location":"tutorials_and_examples/#Tutorials-and-Examples","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"","category":"section"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"Here, you can find detailed explanations on how to build and train specific models with GradValley.jl.","category":"page"},{"location":"tutorials_and_examples/#A-LeNet-like-model-for-handwritten-digit-recognition","page":"Tutorials and Examples","title":"A LeNet-like model for handwritten digit recognition","text":"","category":"section"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"In this tutorial, we will learn the basics of GradValley.jl while building a model for handwritten digit recognition, reaching approximately 99% accuracy on the MNIST-dataset. The whole code at once can be found here.","category":"page"},{"location":"tutorials_and_examples/#Importing-modules","page":"Tutorials and Examples","title":"Importing modules","text":"","category":"section"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"using GradValley # the master module of GradValley.jl\r\nusing GradValley.Layers # The \"Layers\" module provides all the building blocks for creating a model. \r\nusing GradValley.Optimization # The \"Optimization\" module provides different loss functions and optimizers.","category":"page"},{"location":"tutorials_and_examples/#Using-the-dataset","page":"Tutorials and Examples","title":"Using the dataset","text":"","category":"section"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"We will use the MLDatasets package which downloads the MNIST-dataset for us automatically. If you haven't installed MLDatasets yet, write this for installation:","category":"page"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"import Pkg; Pkg.add(\"MLDatasets\")","category":"page"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"Then we can import MLDatasets:","category":"page"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"using MLDatasets # a package for downloading datasets","category":"page"},{"location":"tutorials_and_examples/#Splitting-up-the-dataset-into-a-train-and-a-test-partition","page":"Tutorials and Examples","title":"Splitting up the dataset into a train and a test partition","text":"","category":"section"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"The MNIST-dataset contains 70,000 images, we will use 60,000 images for training the network and 10,000 images for evaluating accuracy.","category":"page"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"# initialize train- and test-dataset\r\nmnist_train = MNIST(:train) \r\nmnist_test = MNIST(:test)","category":"page"},{"location":"tutorials_and_examples/#Using-GradValley.DataLoader-for-handling-data","page":"Tutorials and Examples","title":"Using GradValley.DataLoader for handling data","text":"","category":"section"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"A typical workflow when dealing with datasets is to use the GradValley.DataLoader struct. A data loader makes it easy to iterate directly over the batches in a dataset.  Due to better memory efficiency, the data loader loads the batches just in time. When initializing a data loader, we specify a function that returns exactly one element from the dataset at a given index. We also have to specify the size of the dataset (e.g. the number of images). All parameters that the data loader accepts (see Reference for more information):","category":"page"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"DataLoader(get_function::Function, dataset_size::Integer; batch_size::Integer=1, shuffle::Bool=false, drop_last::Bool=false)","category":"page"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"Now we write the get function for the two data loaders.","category":"page"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"# function for getting an image and the corresponding target vector from the train or test partition\r\nfunction get_element(index, partition)\r\n    # load one image and the corresponding label\r\n    if partition == \"train\"\r\n        image, label = mnist_train[index]\r\n    else # test partition\r\n        image, label = mnist_test[index]\r\n    end\r\n    # add channel dimension and rescaling the values to their original 8 bit gray scale values\r\n    image = reshape(image, 1, 28, 28) .* 255\r\n    # generate the target vector from the label, one for the correct digit, zeros for the wrong digits\r\n    targets = zeros(10)\r\n    targets[label + 1] = 1.00\r\n\r\n    return convert(Array{Float64, 3}, image), targets\r\nend","category":"page"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"We can now initialize the data loaders.","category":"page"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"# initialize the data loaders\r\ntrain_data_loader = DataLoader(index -> get_element(index, \"train\"), length(mnist_train), batch_size=32, shuffle=true)\r\ntest_data_loader = DataLoader(index -> get_element(index, \"test\"), length(mnist_test), batch_size=32)","category":"page"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"If you want to force the data loader to load the data all at once, you could do:","category":"page"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"# force the data loaders to load all the data at once into memory, depending on the dataset's size, this may take a while\r\ntrain_data = train_data_loader[begin:end]\r\ntest_data = test_data_loader[begin:end]","category":"page"},{"location":"tutorials_and_examples/#Building-the-neuronal-network-aka.-the-model","page":"Tutorials and Examples","title":"Building the neuronal network aka. the model","text":"","category":"section"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"The most recommend way to build models is to use the GradValley.Layers.SequentialContainer struct. A SequtialContainer can take an array of layers or other SequentialContainers (sub-models). While forward-pass, the given inputs are sequentially propagated through every layer (or sub-model) and the output will be returned. For more details, see Reference. The LeNet5 model is one of the earliest convolutional neuronal networks (CNNs) reaching approximately 99% accuracy on the MNIST-dataset. The LeNet5 is built of two main parts, the feature extractor and the classifier. So it would be a good idea to clarify that in the code:","category":"page"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"# Definition of a LeNet-like model consisting of a feature extractor and a classifier\r\nfeature_extractor = SequentialContainer([ # a convolution layer with 1 in channel, 6 out channels, a 5*5 kernel and a relu activation\r\n                                         Conv(1, 6, (5, 5), activation_function=\"relu\"),\r\n                                         # an average pooling layer with a 2*2 filter (when not specified, stride is automatically set to kernel size)\r\n                                         AvgPool((2, 2)),\r\n                                         Conv(6, 16, (5, 5), activation_function=\"relu\"),\r\n                                         AvgPool((2, 2))])\r\nflatten = Reshape((256, ))\r\nclassifier = SequentialContainer([ # a fully connected layer (also known as dense or linear) with 256 in features, 120 out features and a relu activation\r\n                                  Fc(256, 120, activation_function=\"relu\"),\r\n                                  Fc(120, 84, activation_function=\"relu\"),\r\n                                  Fc(84, 10),\r\n                                  # a softmax activation layer, the softmax will be calculated along the second dimension (the features dimension)\r\n                                  Softmax(dim=2)])\r\n# The final model consists of three different submodules, \r\n# which shows that a SequentialContainer can contain not only layers, but also other SequentialContainers\r\nmodel = SequentialContainer([feature_extractor, flatten, classifier])","category":"page"},{"location":"tutorials_and_examples/#Printing-a-nice-looking-summary-of-the-model","page":"Tutorials and Examples","title":"Printing a nice looking summary of the model","text":"","category":"section"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"Summarizing a model and counting the number of trainable parameters is easily done with the GradValley.Layers.summarie_model function.","category":"page"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"# printing a nice looking summary of the model\r\nsummary, num_params = summarize_model(model)\r\nprintln(summary)","category":"page"},{"location":"tutorials_and_examples/#Defining-hyperparameters","page":"Tutorials and Examples","title":"Defining hyperparameters","text":"","category":"section"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"Before we start to train and test the model, we define all necessary hyperparameters. If we want to change the learning rate or the loss function for example, this is the one place to do this.","category":"page"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"# defining hyperparameters\r\nloss_function = mse_loss # mean squared error\r\nlearning_rate = 0.05\r\noptimizer = MSGD(model, learning_rate, momentum=0.5) # momentum stochastic gradient descent with a momentum of 0.5\r\nepochs = 5 # 5 or 10","category":"page"},{"location":"tutorials_and_examples/#Train-and-test-the-model","page":"Tutorials and Examples","title":"Train and test the model","text":"","category":"section"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"The next step is to write a function for training the model using the above defined hyperparameters. The network is trained 10 times (epochs) with the entire training data set. After each batch, the weights/parameters of the network are adjusted/optimized. However, we want to test the model after each epoch, so we need to write a function for evaluating the model's accuracy first.","category":"page"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"# evaluate the model's accuracy\r\nfunction test()\r\n    num_correct_preds = 0\r\n    avg_test_loss = 0\r\n    for (batch, (images_batch, targets_batch)) in enumerate(test_data_loader)\r\n        # computing predictions\r\n        predictions_batch = forward(model, images_batch)\r\n        # checking for each image in the batch individually if the prediction is correct\r\n        for index_batch in 1:size(predictions_batch)[1]\r\n            single_prediction = predictions_batch[index_batch, :]\r\n            single_target = targets_batch[index_batch, :]\r\n            if argmax(single_prediction) == argmax(single_target)\r\n                num_correct_preds += 1\r\n            end\r\n        end\r\n        # adding the loss for measuring the average test loss\r\n        avg_test_loss += loss_function(predictions_batch, targets_batch, return_derivative=false)\r\n    end\r\n\r\n    accuracy = num_correct_preds / size(test_data_loader) * 100 # size(data_loader) returns the dataset size\r\n    avg_test_loss /= length(test_data_loader) # length(data_loader) returns the number of batches\r\n\r\n    return accuracy, avg_test_loss\r\nend\r\n\r\n# train the model with the above defined hyperparameters\r\nfunction train()\r\n    for epoch in 1:epochs\r\n\r\n        @time begin # for measuring time taken by one epoch\r\n\r\n            avg_train_loss = 0.00\r\n            # iterating over the whole data set\r\n            for (batch, (images_batch, targets_batch)) in enumerate(train_data_loader)\r\n                # computing predictions\r\n                predictions_batch = forward(model, images_batch)\r\n                # backpropagation\r\n                zero_gradients(model)\r\n                loss, derivative_loss = loss_function(predictions_batch, targets_batch)\r\n                backward(model, derivative_loss)\r\n                # optimize the model's parameters\r\n                step!(optimizer)\r\n                # printing status\r\n                if batch % 100 == 0\r\n                    image_index = batch * train_data_loader.batch_size\r\n                    data_set_size = size(train_data_loader)\r\n                    println(\"Batch $batch, Image [$image_index/$data_set_size], Loss: $(round(loss, digits=5))\")\r\n                end\r\n                # adding the loss for measuring the average train loss\r\n                avg_train_loss += loss\r\n            end\r\n\r\n            avg_train_loss /= length(train_data_loader)\r\n            accuracy, avg_test_loss = test()\r\n            print(\"Results of epoch $epoch: Avg train loss: $(round(avg_train_loss, digits=5)), Avg test loss: $(round(avg_test_loss, digits=5)), Accuracy: $accuracy%, Time taken:\")\r\n\r\n        end\r\n\r\n    end\r\nend","category":"page"},{"location":"tutorials_and_examples/#Run-the-training-and-save-the-trained-model-afterwards","page":"Tutorials and Examples","title":"Run the training and save the trained model afterwards","text":"","category":"section"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"When the file is run as the main script, we want to actually call the train() function and save the final model afterwards. We will use the BSON.jl package for saving the model easily.","category":"page"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"# when this file is run as the main script,\r\n# then train() is run and the final model will be saved using a package called BSON.jl\r\nimport Pkg; Pkg.add(\"MLDatasets\")\r\nusing BSON: @save\r\nif abspath(PROGRAM_FILE) == @__FILE__\r\n    train()\r\n    file_name = \"MNIST_with_LeNet5_model.bson\"\r\n    @save file_name model\r\n    println(\"Saved trained model as $file_name\")\r\nend","category":"page"},{"location":"tutorials_and_examples/#Use-the-trained-model","page":"Tutorials and Examples","title":"Use the trained model","text":"","category":"section"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"If you want to easily use the trained model, you firstly need to import the necessary modules from GradValley. Then you can use the @load macro of BSON to load the model object. Now you can let the model make a few individual predictions, for example. Use this code in an extra file.","category":"page"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"using GradValley\r\nusing GradValley.Layers \r\nusing GradValley.Optimization\r\nusing MLDatasets\r\nusing BSON: @load\r\n\r\n# load the trained model\r\n@load \"MNIST_with_LeNet5_model.bson\" model\r\n\r\n# make some individual predictions\r\nmnist_test = MNIST(:test)\r\nfor i in 1:5\r\n    random_index = rand(1:length(mnist_test))\r\n    image, label = mnist_test[random_index]\r\n    # remember to add batch and channel dimensions and to rescale the image as was done during training and testing\r\n    image_batch = convert(Array{Float64, 4}, reshape(image, 1, 1, 28, 28)) .* 255\r\n    prediction = forward(model, image_batch)\r\n    predicted_label = argmax(prediction[1, :]) - 1\r\n    println(\"Predicted label: $predicted_label, Correct Label: $label\")\r\nend","category":"page"},{"location":"tutorials_and_examples/#Running-the-file-with-multiple-threads","page":"Tutorials and Examples","title":"Running the file with multiple threads","text":"","category":"section"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"It is heavily recommended to run this file, and any other files using GradValley, with multiple threads. Using multiple threads can make training much faster. To do this, use the -t option when running a julia script in terminal/PowerShell/command line/etc. If your CPU has 24 threads, for example, then run:","category":"page"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"julia -t 24 ./MNIST_with_LeNet5.jl","category":"page"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"The specified number of threads should match the number of threads your CPU provides.","category":"page"},{"location":"tutorials_and_examples/#Results","page":"Tutorials and Examples","title":"Results","text":"","category":"section"},{"location":"tutorials_and_examples/","page":"Tutorials and Examples","title":"Tutorials and Examples","text":"These were my results after 5 training epochs: Results of epoch 5: Avg train loss: 0.00237, Avg test loss: 0.00283, Accuracy: 98.21%, Time taken: 13.416619 seconds (20.34 M allocations: 30.164 GiB, 5.86% gc time) On my Ryzen 9 5900X CPU (using all 24 threads, slightly overclocked), one epoch took around ~15 seconds (no compilation time), so the whole training (5 epochs) took around ~75 seconds (no compilation time).","category":"page"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#First-Impressions","page":"Getting Started","title":"First Impressions","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"This example shows the basic workflow on model building and how to use loss functions and optimizers to train the model:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using GradValley\r\nusing GradValley.Layers # The \"Layers\" module provides all the building blocks for creating a model.\r\nusing GradValley.Optimization # The \"Optimization\" module provides different loss functions and optimizers.\r\n\r\n# Definition of a LeNet-like model consisting of a feature extractor and a classifier\r\nfeature_extractor = SequentialContainer([ # a convolution layer with 1 in channel, 6 out channels, a 5*5 kernel and a relu activation\r\n                                         Conv(1, 6, (5, 5), activation_function=\"relu\"),\r\n                                         # an average pooling layer with a 2*2 filter (when not specified, stride is automatically set to kernel size)\r\n                                         AvgPool((2, 2)),\r\n                                         Conv(6, 16, (5, 5), activation_function=\"relu\"),\r\n                                         AvgPool((2, 2))])\r\nflatten = Reshape((256, ))\r\nclassifier = SequentialContainer([ # a fully connected layer (also known as dense or linear) with 256 in features, 120 out features and a relu activation\r\n                                  Fc(256, 120, activation_function=\"relu\"),\r\n                                  Fc(120, 84, activation_function=\"relu\"),\r\n                                  Fc(84, 10),\r\n                                  # a softmax activation layer, the softmax will be calculated along the second dimension (the features dimension)\r\n                                  Softmax(dim=2)])\r\n# The final model consists of three different submodules, \r\n# which shows that a SequentialContainer can contain not only layers, but also other SequentialContainers\r\nmodel = SequentialContainer([feature_extractor, flatten, classifier])\r\n                                  \r\n# feeding the network with some random data\r\ninput = rand(32, 1, 28, 28) # a batch of 32 images with one channel and a size of 28*28 pixels\r\nprediction = forward(model, input) # the forward function can work with a layer or a SequentialContainer\r\n\r\n# choosing an optimizer for training\r\nlearning_rate = 0.05\r\noptimizer = MSGD(model, learning_rate, momentum=0.5) # momentum stochastic gradient decent with a momentum of 0.5\r\n\r\n# generating some random data for a training step\r\ntarget = rand(size(prediction)...)\r\n# backpropagation\r\nzero_gradients(model)\r\nloss, derivative_loss = mse_loss(prediction, target) # mean squared error\r\nbackward(model, derivative_loss) # computing gradients\r\nstep!(optimizer) # making a optimization step with the calculated gradients and the optimizer","category":"page"},{"location":"getting_started/#First-Real-Project","page":"Getting Started","title":"First Real Project","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"Here are some suggestions to implement your first real project with GradValley.jl:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"The \"Hello World\" of Deep Learning: Try the Tutorial on training A LeNet-like model for handwritten digit recognition.\nThe Reference: In the reference, you can find descriptions of all the layers, loss functions and optimizers.\nDownload a pre-trained model: More (Pre-Trained) Models will likely be deployed over time.\nLook at more Tutorials and Examples.","category":"page"},{"location":"(pre-trained)_models/#(Pre-Trained)-Models","page":"(Pre-Trained) Models","title":"(Pre-Trained) Models","text":"","category":"section"},{"location":"(pre-trained)_models/","page":"(Pre-Trained) Models","title":"(Pre-Trained) Models","text":"Unfortunately, no pre-trained models are currently available. Over time, however, models will be made available here.","category":"page"},{"location":"learning/#Learning","page":"Learning","title":"Learning","text":"","category":"section"},{"location":"learning/","page":"Learning","title":"Learning","text":"Unfortunately, no articles are currently available. Over time, however, helpful articles will be made available here.","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"The package can be installed with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and run:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"pkg> add https://github.com/jonas208/GradValley.jl","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Or, equivalently, via the Pkg API:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> import Pkg; Pkg.add(url=\"https://github.com/jonas208/GradValley.jl\")","category":"page"},{"location":"installation/#Used-Dependencies","page":"Installation","title":"Used Dependencies","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"You can look at the Project.toml file to find information about used dependencies and compatibility.","category":"page"},{"location":"installation/#All-used-dependencies-will-be-automatically-installed-due-installation-of-GradValley.jl.","page":"Installation","title":"All used dependencies will be automatically installed due installation of GradValley.jl.","text":"","category":"section"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"warning: Warning\nFor some layers and functions, the documentation is still missing because this documentation is still under construction!","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]\r\nDepth = 4","category":"page"},{"location":"reference/#GradValley","page":"Reference","title":"GradValley","text":"","category":"section"},{"location":"reference/#GradValley.Layers","page":"Reference","title":"GradValley.Layers","text":"","category":"section"},{"location":"reference/#Containers","page":"Reference","title":"Containers","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"SequentialContainer\r\nGraphContainer\r\nsummarize_model","category":"page"},{"location":"reference/#GradValley.Layers.SequentialContainer","page":"Reference","title":"GradValley.Layers.SequentialContainer","text":"SequentialContainer(layer_stack::Vector{<: Any})\n\nA sequential container (recommended method for building models). A SequtialContainer can take a vector of layers or other SequentialContainers (submodules). While forward-pass, the given inputs are sequentially propagated through every layer (or submodule) and the output will be returned. The execution order during forward pass is of course the same as the order in the vector containing the layers or submodules. This container currently (!) only accepts Float64 array inputs. \n\nnote: Note\nYou can use a SequentialContainer in a GraphContainer (and vice versa). You can also use a SequentialContainer in a SequentialContainer (nesting allowed).\n\nArguments\n\nlayer_stack::Vector{<: Any}: the vector containing the layers (or submodules, so other Containers), the order of the modules in the vector corresponds to the execution order\n\nIndexing and Iteration\n\nThe sequential container is indexable and iterable. Indexing one element/iterating behaves like indexing one element of/iterating over  the sequential_container.layer_stack passed to the container at initialization. However, if the index is a range (UnitRange{<: Integer}),  a new SequentialContainer containing all the requested submodules/layers is initialized and returned.  length(sequential_container) and size(sequential_container) both just return the number of modules in the layers vector (equivalent to length(sequential_container.layer_stack)).\n\nExamples\n\n# a simple chain of fully connected layers\njulia> m = SequentialContainer([Fc(1000, 500), Fc(500, 250), Fc(250, 125)])\n# computing the output of the module (with random inputs)\njulia> input = rand(32, 1000)\njulia> output = forward(m, input)\n\n# a more complicated example with with nested submodules\njulia> feature_extractor_part_1 = SequentialContainer([Conv(1, 6, (5, 5), activation_function=\"relu\"), AvgPool((2, 2))])\njulia> feature_extractor_part_2 = SequentialContainer([Conv(6, 16, (5, 5), activation_function=\"relu\"), AvgPool((2, 2))])\njulia> feature_extractor = SequentialContainer([feature_extractor_part_1, feature_extractor_part_2])\njulia> classifier = SequentialContainer([Fc(256, 120, activation_function=\"relu\"), Fc(120, 84, activation_function=\"relu\"), Fc(84, 10)])\njulia> m = SequentialContainer([feature_extractor, Reshape((256, )), classifier, Softmax(dim=2)])\n# computing the output of the module (with random inputs)\njulia> input = rand(32, 1, 28, 28)\njulia> output = forward(m, input)\n\n# indexing \njulia> m[start] # returns the feature_extractor_part_1 submodule (SequentialContainer)\njulia> m[end] # returns the softmax layer (Softmax)\njulia> m[start:end-1] # returns the entire model except the softmax layer (a new SequentialContainer is initialized and returned) \n\n# if a SequentialContainer contains BatchNorm layers (regardless of whether they are nested somewhere in a submodule or not), \n# the mode of all these layers at once can be switched as follows\njulia> trainmode!(m)\njulia> testmode!(m)\n\n# if a SequentialContainer contains layers with trainable parameters/weights (what is hopefully in nearly all situations the case),\n# regardless of whether they are nested somewhere in a submodule or not, the gradients of all these layers at once can be reset as follows\njulia> zero_gradients(m)\n\n\n\n\n\n","category":"type"},{"location":"reference/#GradValley.Layers.GraphContainer","page":"Reference","title":"GradValley.Layers.GraphContainer","text":"GraphContainer(forward_pass::Function, layer_stack::Vector{<: Any})\n\nA computational graph container (recommended method for building models). A GraphContainer can take a function representing the forward pass of a model and a vector of layers or other containers (submodules). While forward-pass, a tracked version of the given inputs are passed through the given forward pass function and the output will be returned. During forward pass, the computational graph is build by a function overload based automatic differentiation system (AD). During backward pass, this computational graph  is used to compute the gradients. This container currently (!) only accepts Float64 array inputs. \n\nnote: Note\nYou can use a GraphContainer in a SequentialContainer (and vice versa). You can also use a GraphContainer in a GraphContainer (nesting allowed).\n\nwarning: Warning\nNote that the GraphContainer is an experimental feature. The behavior of this module could change dramatically in the future. Using this module can may cause problems.\n\nArguments\n\nforward_pass::Function: the function representing the forward pass of a model\nlayer_stack::Vector{<: Any}: the vector containing the layers (or submodules, so other Containers), the order doesn't matter\n\nGuidelines\n\nGradValley has its own little, rudimentary function overload based automatic differentiation system based on ChainRules.jl. It was designed to allow simple modifications of a normal sequential signal flow, which is the basis of most neural networks.  For example, to be able to implement ResNet's residual connections. So it represents an alternative to data flow layers known from other Deep Learning packages. In a way, it is similar to the forward function known from every PyTorch model. Since the AD does not offer that much functionality at this point in time, the following guidelines must be observed:\n\nThe forward pass function must take at least two arguments. The first is the vector containing the layers (which was passed to GraphContainer at initialization). The following arguments (the last could also be a Vararg argument) are the data inputs.\nThe forward pass function must be written generically enough to accept arrays of type T<:AbstractArray/real numbers of type T<:Real as input (starting with the second argument).\nArray inputs that are being differentiated cannot be mutated.\nThe initialization of new arrays (for example with zeros or rand) and their use in mix with the input passed to the forward function is not allowed.\nAvoid dot syntax in most cases, there only exist a few differentiation rules for the most basic vectorized operators (.+, .-, .*, ./, .^).\n\nExamples\n\n# a simple chain of fully connected layers (equivalent to the first example of SequentialContainer)\njulia> layers = [Fc(1000, 500), Fc(500, 250), Fc(250, 125)]\njulia> function forward_pass(layers::Vector, input::AbstractArray)\n           fc_1, fc_2, fc_3 = layers\n           output = forward(fc_1, input)\n           output = forward(fc_2, output)\n           output = forward(fc_3, output)\n           return output\n       end\njulia> m = GraphContainer(forward_pass, layers)\n# computing the output of the module (with random inputs)\njulia> input = rand(32, 1000)\njulia> output = forward(m, input)\n\n# a more complicated example: implementation of an inverted residual block\njulia> layers = [Conv(16, 64, (1, 1), activation_function=\"relu\"), \n                 DepthwiseConv(64, 64, (3, 3), padding=(1, 1), activation_function=\"relu\"), \n                 Conv(64, 16, (1, 1), activation_function=\"relu\")]\njulia> function forward_pass(layers::Vector, input::AbstractArray)\n           conv_1, depthwise_conv, conv_2 = layers\n           output = forward(conv_1, input)\n           output = forward(depthwise_conv, output)\n           output = forward(conv_2, output)\n           output = output + input # residual/skipped connection\n           return output\n       end\njulia> m = GraphContainer(forward_pass, layers)\n# computing the output of the module (with random inputs)\njulia> input = rand(32, 16, 50, 50)\njulia> output = forward(m, input)\n\n# a simple example with a polynomial, just to show that it is possible to use the GraphContainer like an automatic differentiation (AD) tool \njulia> f(layers, x) = 0.5x^3 - 2x^2 + 10\njulia> df(x) = 1.5x^2 - 4x # checking the result of the AD with this manually written derivation \njulia> m = GraphContainer(f, [])\njulia> y = forward(m, 3)\njulia> dydx = backward(m, 1) # in this case, no loss function was used, so we have no gradient information, therefore we use 1 as the so-called seed\n1-element Vector{Float64}:\n 1.5\njulia> manual_dydx = df(3)\n1.5\njulia> isapprox(dydx[1], manual_dydx)\ntrue\n\n# if a GraphContainer contains BatchNorm layers (regardless of whether they are nested somewhere in a submodule or not), \n# the mode of all these layers at once can be switched as follows\njulia> trainmode!(m)\njulia> testmode!(m)\n\n# if a GraphContainer contains layers with trainable parameters/weights (what is hopefully in nearly all situations the case),\n# regardless of whether they are nested somewhere in a submodule or not, the gradients of all these layers at once can be reset as follows\njulia> zero_gradients(m)\n\n\n\n\n\n","category":"type"},{"location":"reference/#GradValley.Layers.summarize_model","page":"Reference","title":"GradValley.Layers.summarize_model","text":"summarize_model(container::Union{SequentialContainer, GraphContainer})\n\nReturn a string (and the total number of parameters) intended for printing with an overview of the model  (currently doesn't show an visualization of the computational graph) and its number of parameters.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Forward-and-Backward-Pass","page":"Reference","title":"Forward- and Backward-Pass","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"forward\r\nbackward","category":"page"},{"location":"reference/#GradValley.Layers.forward","page":"Reference","title":"GradValley.Layers.forward","text":"forward(layer, input::Array{Float64})\n\nThe forward function for computing the output of a module. For every layer/container, an individual method exists. However, all these methods work exactly the same. They all take the layer/container as the first argument and the input data as the second argument. The output is returned.  All layers/containers currently (!) only accept Float64 array inputs, so all methods also expect a Float64 array input, the number of dimensions can differ.\n\nExamples\n\n# define some layers and containers\njulia> layer = Conv(3, 6, (5, 5))\njulia> container = SequentialContainer([Fc(1000, 500), Fc(500, 250), Fc(250, 125)])\n# create some random input data\njulia> layer_input = rand(32, 3, 50, 50)\njulia> container_input = rand(32, 1000)\n# compute the output of the modules\njulia> layer_output = forward(layer, layer_input)\njulia> container_output = forward(container, container_input)\n\n\n\n\n\n","category":"function"},{"location":"reference/#GradValley.Layers.backward","page":"Reference","title":"GradValley.Layers.backward","text":"backward(layer, next_layer)\n\nThe backward function for computing the gradients for a layer. Also well known as backpropagation. For every layer, an individual method exists. However, all these methods work exactly the same. They all take the current layer for which the gradients should be computed as the first argument  and next layer containing the backpropagated losses used to compute the gradients for the current layer. No gradients are returned, they are just saved in the layer.\n\nwarning: Warning\nNote that this backward function differs from the backward functions for containers. As a user, it is highly recommended to use containers for model building because they create the forward and backward pass automatically. Calling the backward functions for all the layers individually is normally not necessary and also not recommended.\n\nExamples\n\n# define two layers  \njulia> layer_1 = Fc(500, 250)\njulia> layer_2 = Fc(250, 125)\n# compute the output of the layers (with random inputs)\njulia> output = forward(layer_1, rand(32, 500))\njulia> output = forward(layer_2, output)\n# use a loss function (with random data as target values) and save the derivative of the loss\njulia> loss, derivative_loss = mse_loss(output, rand(32, 125)) # note that GradValley.Optimization.mse_loss must be imported\n# before the gradients are recalculated, the old gradients should always be reset first\njulia> zero_gradients(layer_1)\njulia> zero_gradients(layer_2)\n# backpropagation (compute the gradients to the weights and backpropagate the losses)\n# because there exists no next layer after the last layer to take the backpropagted losses from, we will have to manually store the derivative of the loss in the last layer\njulia> layer_2.losses = derivative_loss\n# than we can compute the gradients to the weights and backpropagate the losses\ncompute_gradients(layer_2)\ncompute_previous_losses(layer_2)\n# now we can go on with the actual backward function\nbackward(layer_1, layer_2)\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reset/zero-gradients","page":"Reference","title":"Reset/zero gradients","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"zero_gradients","category":"page"},{"location":"reference/#GradValley.Layers.zero_gradients","page":"Reference","title":"GradValley.Layers.zero_gradients","text":"zero_gradients(layer_or_container)\n\nResets the gradients of a layer or a container (any kind of module with trainable parameters). \n\nThere only exists methods for layers with parameters, however, if a container without layers with trainable parameters is given, NO error will be thrown. So if the given container contains layers with trainable parameters/weights, regardless of whether they are nested somewhere in a submodule or not,  the gradients of all these layers at once will be reset.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Training-mode/test-mode","page":"Reference","title":"Training mode/test mode","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"trainmode!\r\ntestmode!","category":"page"},{"location":"reference/#GradValley.Layers.trainmode!","page":"Reference","title":"GradValley.Layers.trainmode!","text":"trainmode!(batch_norm_layer_or_container)\n\nSwitches the mode of the given batch normalization layer or container to training mode. See Normalization\n\nIf the given container contains batch normalization layers (regardless of whether they are nested somewhere in a submodule or not),  the mode of all these layers at once will be switched to training mode.\n\n\n\n\n\n","category":"function"},{"location":"reference/#GradValley.Layers.testmode!","page":"Reference","title":"GradValley.Layers.testmode!","text":"testmode!(batch_norm_layer_or_container)\n\nSwitches the mode of the given batch normalization layer or container to test mode. See Normalization\n\nIf the given container contains batch normalization layers (regardless of whether they are nested somewhere in a submodule or not),  the mode of all these layers at once will be switched to test mode.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Convolution","page":"Reference","title":"Convolution","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Conv\r\nDepthwiseConv\r\nConvTranspose","category":"page"},{"location":"reference/#GradValley.Layers.Conv","page":"Reference","title":"GradValley.Layers.Conv","text":"Conv(in_channels::Int, out_channels::Int, kernel_size::Tuple{Int, Int}; stride::Tuple{Int, Int}=(1, 1), padding::Tuple{Int, Int}=(0, 0), dilation::Tuple{Int, Int}=(1, 1), groups::Int=1, activation_function::Union{Nothing, String}=nothing, init_mode::String=\"default_uniform\", use_bias::Bool=true)\n\nA convolution layer. Apply a 2D convolution over an input signal with additional batch and channel dimensions. This layer currently (!) only accepts Float64 array inputs. \n\nArguments\n\nin_channels::Int: the number of channels in the input image\nout_channels::Int: the number of channels produced by the convolution\nkernel_size::Tuple{Int, Int}: the size of the convolving kernel\nstride::Tuple{Int, Int}=(1, 1): the stride of the convolution\npadding::Tuple{Int, Int}=(0, 0): the zero padding added to all four sides of the input\ndilation::Tuple{Int, Int}=(1, 1): the spacing between kernel elements\ngroups::Int=1: the number of blocked connections from input channels to output channels (in-channels and out-channels must both be divisible by groups)\nactivation_function::Union{Nothing, String}=nothing: the element-wise activation function which will be applied to the output after the convolution \ninit_mode::String=\"default_uniform\": the initialization mode of the weights   (can be \"default_uniform\", \"default\", \"kaiming_uniform\", \"kaiming\", \"xavier_uniform\" or \"xavier\")\nuse_bias::Bool=true: if true, adds a learnable bias to the output\n\nShapes\n\nInput: (N C_in H_in W_in)\nWeight: (C_out fracC_ingroups H_w W_w)\nBias: (C_out )\nOutput: (N C_out H_out W_out), where \nH_out = fracH_in + 2 cdot padding1 - dilation1 cdot (H_w - 1)stride1 + 1\nW_out = fracW_in + 2 cdot padding2 - dilation2 cdot (W_w - 1)stride2 + 1\n\nUseful Fields/Variables\n\nkernels::Array{Float64, 4}: the learnable weights of the layer\nbias::Vector{Float64}: the learnable bias of the layer (used when use_bias=true)\ngradients::Array{Float64, 4}: the current gradients of the weights/kernels\nbias_gradients::Vector{Float64}: the current gradients of the bias\n\nDefinition\n\nFor one group, a multichannel 2D convolution (disregarding batch dimension and activation function) can be described as:\n\no_c_out y_out x_out = big(sum_c_in=1^C_insum_y_w=1^H_wsum_x_w=1^W_w i_c_in y_in x_in cdot w_c_out c_in y_w x_wbig) + b_c_out, where\ny_in = y_out + (stride1 - 1) cdot (y_out - 1) + (y_w - 1) cdot dilation1\nx_in = x_out + (stride2 - 1) cdot (x_out - 1) + (x_w - 1) cdot dilation2\n\nO is the output array, I the input array, W the weight array and B the bias array.\n\nExamples\n\n# square kernels and fully default values of keyword arguments\njulia> m = Conv(3, 6, (5, 5))\n# non-square kernels and unequal stride and with padding as well as specified weight initialization mode\n# (init_mode=\"kaiming\" stands for kaiming weight initialization with normally distributed values)\njulia> m = Conv(3, 6, (3, 5), stride=(2, 1), padding=(2, 1))\n# non-square kernels and unequal stride and with padding, dilation and 3 groups\n# (because groups=in_channels and out_channles is divisible by groups, it is even a depthwise convolution)\njulia> m = Conv(3, 6, (3, 5), stride=(2, 1), padding=(4, 2), dilation=(3, 1), groups=3)\n# computing the output of the layer (with random inputs)\njulia> input = rand(32, 3, 50, 50)\njulia> output = forward(m, input)\n\n\n\n\n\n","category":"type"},{"location":"reference/#GradValley.Layers.DepthwiseConv","page":"Reference","title":"GradValley.Layers.DepthwiseConv","text":"DepthwiseConv(in_channels::Int, out_channels::Int, kernel_size::Tuple{Int, Int}; stride::Tuple{Int, Int}=(1, 1), padding::Tuple{Int, Int}=(0, 0), dilation::Tuple{Int, Int}=(1, 1), activation_function::Union{Nothing, String}=nothing, init_mode::String=\"default_uniform\", use_bias::Bool=true)\n\nA depthwise convolution layer. Apply a 2D depthwise convolution over an input signal with additional batch and channel dimensions. This layer currently (!) only accepts Float64 array inputs. \n\nArguments\n\nin_channels::Int: the number of channels in the input image\nout_channels::Int: the number of channels produced by the convolution\nkernel_size::Tuple{Int, Int}: the size of the convolving kernel\nstride::Tuple{Int, Int}=(1, 1): the stride of the convolution\npadding::Tuple{Int, Int}=(0, 0): the zero padding added to all four sides of the input\ndilation::Tuple{Int, Int}=(1, 1): the spacing between kernel elements\nactivation_function::Union{Nothing, String}=nothing: the element-wise activation function which will be applied to the output after the convolution \ninit_mode::String=\"default_uniform\": the initialization mode of the weights   (can be \"default_uniform\", \"default\", \"kaiming_uniform\", \"kaiming\", \"xavier_uniform\" or \"xavier\")\nuse_bias::Bool=true: if true, adds a learnable bias to the output\n\nShapes\n\nInput: (N C_in H_in W_in)\nWeight: (C_out fracC_ingroups H_w W_w), where groups = in_channels\nBias: (C_out )\nOutput: (N C_out H_out W_out), where \nH_out = fracH_in + 2 cdot padding1 - dilation1 cdot (H_w - 1)stride1 + 1\nW_out = fracW_in + 2 cdot padding2 - dilation2 cdot (W_w - 1)stride2 + 1\n\nUseful Fields/Variables\n\nkernels::Array{Float64, 4}: the learnable weights of the layer\nbias::Vector{Float64}: the learnable bias of the layer (used when use_bias=true)\ngradients::Array{Float64, 4}: the current gradients of the weights/kernels\nbias_gradients::Vector{Float64}: the current gradients of the bias\n\nDefinition\n\nA convolution is called depthwise if groups=in_channels and out_channels=k cdot in_channels, where k is a positive integer. The second condition ensures that the of number out-channels is divisible by the number of groups/in-channels. In the background, the standard convolution operation is also used for this layer.  It is just an interface making clear that this layer can only perform a depthwise convolution.\n\nExamples\n\n# square kernels and fully default values of keyword arguments\njulia> m = DepthwiseConv(3, 6, (5, 5))\n# non-square kernels and unequal stride and with padding as well as specified weight initialization mode\n# (init_mode=\"kaiming\" stands for kaiming weight initialization with normally distributed values)\njulia> m = DepthwiseConv(3, 6, (3, 5), stride=(2, 1), padding=(2, 1))\n# non-square kernels and unequal stride and with padding, dilation and 3 groups\n# (because groups=in_channels and out_channles is divisible by groups, it is even a depthwise convolution)\njulia> m = DepthwiseConv(3, 6, (3, 5), stride=(2, 1), padding=(4, 2), dilation=(3, 1), groups=3)\n# computing the output of the layer (with random inputs)\njulia> input = rand(32, 3, 50, 50)\njulia> output = forward(m, input)\n\n\n\n\n\n","category":"type"},{"location":"reference/#GradValley.Layers.ConvTranspose","page":"Reference","title":"GradValley.Layers.ConvTranspose","text":"ConvTranspose(in_channels::Int, out_channels::Int, kernel_size::Tuple{Int, Int}; stride::Tuple{Int, Int}=(1, 1), padding::Tuple{Int, Int}=(0, 0), output_padding::Tuple{Int, Int}=(0, 0), dilation::Tuple{Int, Int}=(1, 1), groups::Int=1, activation_function::Union{Nothing, String}=nothing, init_mode::String=\"default_uniform\", use_bias::Bool=true)\n\nA transpose convolution layer (also known as fractionally-strided convolution or deconvolution). Apply a 2D transposed convolution over an input signal with additional batch and channel dimensions. This layer currently (!) only accepts Float64 array inputs. \n\nArguments\n\nin_channels::Int: the number of channels in the input image\nout_channels::Int: the number of channels produced by the convolution\nkernel_size::Tuple{Int, Int}: the size of the convolving kernel\nstride::Tuple{Int, Int}=(1, 1): the stride of the convolution\npadding::Tuple{Int, Int}=(0, 0): because transposed convolution can be seen as a partly (not true) inverse of convolution, padding means is this case to cut off the desired number of pixels on each side (instead of adding pixels)\noutput_padding::Tuple{Int, Int}=(0, 0): additional size added to one side of each dimension in the output shape (note that output_padding is only used to calculate the output shape, but does not actually add zero-padding to the output)\ndilation::Tuple{Int, Int}=(1, 1): the spacing between kernel elements\ngroups::Int=1: the number of blocked connections from input channels to output channels (in-channels and out-channels must both be divisible by groups)\nactivation_function::Union{Nothing, String}=nothing: the element-wise activation function which will be applied to the output after the convolution \ninit_mode::String=\"default_uniform\": the initialization mode of the weights   (can be \"default_uniform\", \"default\", \"kaiming_uniform\", \"kaiming\", \"xavier_uniform\" or \"xavier\")\nuse_bias::Bool=true: if true, adds a learnable bias to the output\n\nShapes\n\nInput: (N C_in H_in W_in)\nWeight: (C_in fracC_outgroups H_w W_w)\nBias: (C_out )\nOutput: (N C_out H_out W_out), where \nH_out = (H_in - 1) cdot stride1 - 2 cdot padding1 + dilation1 cdot (H_w - 1) + output_padding1 + 1\nW_out = (W_in - 1) cdot stride2 - 2 cdot padding2 + dilation2 cdot (W_w - 1) + output_padding2 + 1\n\nUseful Fields/Variables\n\nkernels::Array{Float64, 4}: the learnable weights of the layer\nbias::Vector{Float64}: the learnable bias of the layer (used when use_bias=true)\ngradients::Array{Float64, 4}: the current gradients of the weights/kernels\nbias_gradients::Vector{Float64}: the current gradients of the bias\n\nDefinition\n\nA transposed convolution can be seen as the gradient of a normal convolution with respect to its inputs.  The forward pass of a transposed convolution is the backward pass of a normal convolution, so the forward pass of a normal convolution becomes the backward pass of a transposed convolution (with respect to its inputs).  For more detailed information, you can look at the source code of (transposed) convolution. A nice looking visualization of (transposed) convolution can be found here.\n\nExamples\n\n# square kernels and fully default values of keyword arguments\njulia> m = ConvTranspose(6, 3, (5, 5))\n# upsampling an output from normal convolution like in DCGANS, Unet, etc.\njulia> input = forward(Conv(3, 6, (5, 5)), rand(32, 3, 50, 50))\njulia> output = forward(m, input)\n# the size of the output of the transposed convolution is equal to the size of the original input of the normal convolution\njulia> size(output)\n(32, 3, 50, 50)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Pooling","page":"Reference","title":"Pooling","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MaxPool\r\nAvgPool\r\nAdaptiveMaxPool\r\nAdaptiveAvgPool","category":"page"},{"location":"reference/#GradValley.Layers.MaxPool","page":"Reference","title":"GradValley.Layers.MaxPool","text":"MaxPool(kernel_size::Tuple{Int, Int}; stride::Tuple{Int, Int}=kernel_size, padding::Tuple{Int, Int}=(0, 0), dilation::Tuple{Int, Int}=(1, 1), activation_function::Union{Nothing, String}=nothing)\n\nA maximum pooling layer. Apply a 2D maximum pooling over an input signal with additional batch and channel dimensions. This layer currently (!) only accepts Float64 array inputs. \n\nArguments\n\nkernel_size::Tuple{Int, Int}: the size of the window to take the maximum over\nstride::Tuple{Int, Int}=kernel_size: the stride of the window\npadding::Tuple{Int, Int}=(0, 0): the zero padding added to all four sides of the input\ndilation::Tuple{Int, Int}=(1, 1): the spacing between the window elements\nactivation_function::Union{Nothing, String}=nothing: the element-wise activation function which will be applied to the output after the pooling\n\nShapes\n\nInput: (N C H_in W_in)\nOutput: (N C H_out W_out), where \nH_out = fracH_in + 2 cdot padding1 - dilation1 cdot (kernel_size1 - 1)stride1 + 1\nW_out = fracW_in + 2 cdot padding2 - dilation2 cdot (kernel_size2 - 1)stride2 + 1\n\nDefinition\n\nA multichannel 2D maximum pooling (disregarding batch dimension and activation function) can be described as:\n\nbeginalign*\no_c y_out x_out = max\n_y_w = 1  kernel_size1  x_w = 1  kernel_size2\ni_c y_in x_in\nendalign*\n\nWhere\n\ny_in = y_out + (stride1 - 1) cdot (y_out - 1) + (y_w - 1) cdot dilation1\nx_in = x_out + (stride2 - 1) cdot (x_out - 1) + (x_w - 1) cdot dilation2\n\nO is the output array and I the input array.\n\nExamples\n\n# pooling of square window of size=(3, 3) and automatically selected stride\njulia> m = MaxPool((3, 3))\n# pooling of non-square window with custom stride and padding\njulia> m = MaxPool((3, 2), stride=(2, 1), padding=(1, 1))\n# computing the output of the layer (with random inputs)\njulia> input = rand(32, 3, 50, 50)\njulia> output = forward(m, input)\n\n\n\n\n\n","category":"type"},{"location":"reference/#GradValley.Layers.AvgPool","page":"Reference","title":"GradValley.Layers.AvgPool","text":"AvgPool(kernel_size::Tuple{Int, Int}; stride::Tuple{Int, Int}=kernel_size, padding::Tuple{Int, Int}=(0, 0), dilation::Tuple{Int, Int}=(1, 1), activation_function::Union{Nothing, String}=nothing)\n\nAn average pooling layer. Apply a 2D average pooling over an input signal with additional batch and channel dimensions. This layer currently (!) only accepts Float64 array inputs. \n\nArguments\n\nkernel_size::Tuple{Int, Int}: the size of the window to take the average over\nstride::Tuple{Int, Int}=kernel_size: the stride of the window\npadding::Tuple{Int, Int}=(0, 0): the zero padding added to all four sides of the input\ndilation::Tuple{Int, Int}=(1, 1): the spacing between the window elements\nactivation_function::Union{Nothing, String}=nothing: the element-wise activation function which will be applied to the output after the pooling\n\nShapes\n\nInput: (N C H_in W_in)\nOutput: (N C H_out W_out), where \nH_out = fracH_in + 2 cdot padding1 - dilation1 cdot (kernel_size1 - 1)stride1 + 1\nW_out = fracW_in + 2 cdot padding2 - dilation2 cdot (kernel_size2 - 1)stride2 + 1\n\nDefinition\n\nA multichannel 2D average pooling (disregarding batch dimension and activation function) can be described as:\n\no_c y_out x_out = frac1kernel_size1 cdot kernel_size2 sum_i=1^kernel_size1sum_j=1^kernel_size2 i_c y_in x_in, where\ny_in = y_out + (stride1 - 1) cdot (y_out - 1) + (y_w - 1) cdot dilation1\nx_in = x_out + (stride2 - 1) cdot (x_out - 1) + (x_w - 1) cdot dilation2\n\nO is the output array and I the input array.\n\nExamples\n\n# pooling of square window of size=(3, 3) and automatically selected stride\njulia> m = AvgPool((3, 3))\n# pooling of non-square window with custom stride and padding\njulia> m = AvgPool((3, 2), stride=(2, 1), padding=(1, 1))\n# computing the output of the layer (with random inputs)\njulia> input = rand(32, 3, 50, 50)\njulia> output = forward(m, input)\n\n\n\n\n\n","category":"type"},{"location":"reference/#GradValley.Layers.AdaptiveMaxPool","page":"Reference","title":"GradValley.Layers.AdaptiveMaxPool","text":"AdaptiveMaxPool(output_size::Tuple{Int, Int}; activation_function::Union{Nothing, String}=nothing)\n\nAn adaptive maximum pooling layer. Apply a 2D adaptive maximum pooling over an input signal with additional batch and channel dimensions. For any input size, the size of the output is always equal to the specified output_size. This layer currently (!) only accepts Float64 array inputs. \n\nArguments\n\noutput_size::Tuple{Int, Int}: the target output size of the image (can even be larger than the input size) of the form (H_out W_out)\nactivation_function::Union{Nothing, String}=nothing: the element-wise activation function which will be applied to the output after the pooling\n\nShapes\n\nInput: (N C H_in W_in)\nOutput: (N C H_out W_out), where (H_out W_out) = output_size\n\nDefinition\n\nIn some cases, the kernel-size and stride could be calculated in a way that the output would have the target size  (using a standard maximum pooling with the calculated kernel-size and stride, padding and dilation would not  be used in this case). However, this approach would only work if the input size is an integer multiple of the output size (See this question at stack overflow for further information: stackoverflow.com/questions/53841509/how-does-adaptive-pooling-in-pytorch-work). A more generic approach is to calculate the indices of the input with an additional algorithm only for adaptive pooling.  With this approach, it is even possible that the output is larger than the input what is really unusual for pooling simply because that is the opposite of what pooling actually should do, namely reducing the size. The function get_in_indices(in_len, out_len) in  gv_functional.jl (line 95 - 113) implements such an algorithm (similar to the one at the stack overflow question), so you could check there on how exactly it is defined. Thus, the mathematical definition would be identical to the one at MaxPool with the difference that the indices y_in and x_in  have already been calculated beforehand.\n\nExamples\n\n# target output size of 5x5\njulia> m = AdaptiveMaxPool((5, 5))\n# computing the output of the layer (with random inputs)\njulia> input = rand(32, 3, 50, 50)\njulia> output = forward(m, input)\n\n\n\n\n\n","category":"type"},{"location":"reference/#GradValley.Layers.AdaptiveAvgPool","page":"Reference","title":"GradValley.Layers.AdaptiveAvgPool","text":"AdaptiveAvgPool(output_size::Tuple{Int, Int}; activation_function::Union{Nothing, String}=nothing)\n\nAn adaptive average pooling layer. Apply a 2D adaptive average pooling over an input signal with additional batch and channel dimensions. For any input size, the size of the output is always equal to the specified output_size. This layer currently (!) only accepts Float64 array inputs. \n\nArguments\n\noutput_size::Tuple{Int, Int}: the target output size of the image (can even be larger than the input size) of the form (H_out W_out)\nactivation_function::Union{Nothing, String}=nothing: the element-wise activation function which will be applied to the output after the pooling\n\nShapes\n\nInput: (N C H_in W_in)\nOutput: (N C H_out W_out), where (H_out W_out) = output_size\n\nDefinition\n\nIn some cases, the kernel-size and stride could be calculated in a way that the output would have the target size  (using a standard average pooling with the calculated kernel-size and stride, padding and dilation would not  be used in this case). However, this approach would only work if the input size is an integer multiple of the output size (See this question at stack overflow for further information: stackoverflow.com/questions/53841509/how-does-adaptive-pooling-in-pytorch-work). A more generic approach is to calculate the indices of the input with an additional algorithm only for adaptive pooling.  With this approach, it is even possible that the output is larger than the input what is really unusual for pooling simply because that is the opposite of what pooling actually should do, namely reducing the size. The function get_in_indices(in_len, out_len) in  gv_functional.jl (line 95 - 113) implements such an algorithm (similar to the one at the stack overflow question), so you could check there on how exactly it is defined. Thus, the mathematical definition would be identical to the one at AvgPool with the difference that the indices y_in and x_in  have already been calculated beforehand.\n\nExamples\n\n# target output size of 5x5\njulia> m = AdaptiveAvgPool((5, 5))\n# computing the output of the layer (with random inputs)\njulia> input = rand(32, 3, 50, 50)\njulia> output = forward(m, input)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Fully-connected","page":"Reference","title":"Fully connected","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Fc","category":"page"},{"location":"reference/#GradValley.Layers.Fc","page":"Reference","title":"GradValley.Layers.Fc","text":"Fc(in_features::Int, out_features::Int; activation_function::Union{Nothing, String}=nothing, init_mode::String=\"default_uniform\", use_bias::Bool=true)\n\nA fully connected layer (sometimes also known as dense or linear). Apply a linear transformation (matrix multiplication) to the input signal with additional batch dimension. This layer currently (!) only accepts Float64 array inputs. \n\nArguments\n\nin_features::Int: the size of each input sample (\"number of input neurons\")\nout_features::Int: the size of each output sample (\"number of output neurons\")\nactivation_function::Union{Nothing, String}=nothing: the element-wise activation function which will be applied to the output\ninit_mode::String=\"default_uniform\": the initialization mode of the weights   (can be \"default_uniform\", \"default\", \"kaiming_uniform\", \"kaiming\", \"xavier_uniform\" or \"xavier\")\n\nuse_bias::Bool=true: if true, adds a learnable bias to the output\n\nShapes\n\nInput: (N in_features)\nWeight: (out_features in_features)\nBias: (out_features )\nOutput: (N out_features)\n\nUseful Fields/Variables\n\nweights::Array{Float64, 2}: the learnable weights of the layer\nbias::Vector{Float64}: the learnable bias of the layer (used when use_bias=true)\ngradients::Array{Float64, 2}: the current gradients of the weights\nbias_gradients::Vector{Float64}: the current gradients of the bias\n\nDefinition\n\nThe forward pass of a fully connected layer is given by the matrix multiplication between the weight matrix and the input vector  (disregarding batch dimension and activation function):\n\nO = WI + B\n\nThis operation can also be described by:\n\no_j = big(sum_k=1^in_features w_jk cdot i_kbig) + b_j\n\nO is the output vector, I the input vector, W the weight matrix and B the bias vector. Visually interpreted, it means that each input neuron i is weighted with the corresponding weight w connecting the input neuron  to the output neuron o where all the incoming signals are summed up.\n\nExamples\n\n# a fully connected layer with 784 input features and 120 output features\njulia> m = Fc(784, 120)\n# computing the output of the layer (with random inputs)\njulia> input = rand(32, 784)\njulia> output = forward(m, input)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Identity","page":"Reference","title":"Identity","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Identity","category":"page"},{"location":"reference/#GradValley.Layers.Identity","page":"Reference","title":"GradValley.Layers.Identity","text":"Identity(; activation_function::Union{Nothing, String}=nothing)\n\nAn identity layer (can be used as an activation function layer). If no activation function is used, this layer does not change the signal in any way. However, if an activation function is used, the activation function will be applied to the inputs element-wise.  This layer currently (!) only accepts Float64 array inputs. \n\ntip: Tip\nThis layer is helpful to apply an element-wise activation independent of a \"normal\" computational layer.\n\nArguments\n\nactivation_function::Union{Nothing, String}=nothing: the element-wise activation function which will be applied to the inputs\n\nShapes\n\nInput: (*), where * means any number of dimensions\nOutput: (*) (same shape as input)\n\nDefinition\n\nA placeholder identity operator, except the optional activation function, the input signal is not changed in any way. If an activation function is used, the activation function will be applied to the inputs element-wise. \n\nExamples\n\n# an independent relu activation\njulia> m = Identity(activation_function=\"relu\")\n# computing the output of the layer (with random inputs)\njulia> input = rand(32, 10)\njulia> output = forward(m, input)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Normalization","page":"Reference","title":"Normalization","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"BatchNorm2d","category":"page"},{"location":"reference/#GradValley.Layers.BatchNorm2d","page":"Reference","title":"GradValley.Layers.BatchNorm2d","text":"BatchNorm2d(num_features::Int; epsilon::Float64=1e-05, momentum::Float64=0.1, affine::Bool=true, track_running_stats::Bool=true, activation_function::Union{Nothing, String}=nothing)\n\nA batch normalization layer. Apply a batch normalization over a 4D input signal (a mini-batch of 2D inputs with additional channel dimension). This layer currently (!) only accepts Float64 array inputs. \n\nThis layer has two modes: training mode and test mode. If track_running_stats::Bool=true, this layer behaves differently in the two modes. During training, this layer always uses the currently calculated batch statistics. If track_running_stats::Bool=true, the running mean and variance are tracked during training and will be used while testing. If track_running_stats::Bool=false, even in test mode, the currently calculated batch statistics are used. The mode can be switched with trainmode! or testmode! respectively. The training mode is active by default.\n\nArguments\n\nnum_features::Int: the number of channels\nepsilon::Float64=1e-05: a value added to the denominator for numerical stability\nmomentum::Float64=0.1: the value used for the running mean and running variance computation\naffine::Bool=true: if true, this layer uses learnable affine parameters/weights (gamma and beta)\ntrack_running_stats::Bool=true: if true, this layer tracks the running mean and variance during training and will use them for testing/evaluation, if false, such statistics are not tracked and, even in test mode, the batch statistics are always recalculated for each new input\nactivation_function::Union{Nothing, String}=nothing: the element-wise activation function which will be applied to the output\n\nShapes\n\nInput: (N C H W)\ngamma Weight, beta Bias: (C )\nRunning Mean/Variance: (C )\nOutput: (N C H W) (same shape as input)\n\nUseful Fields/Variables\n\nWeights (used if affine::Bool=true)\n\nweight_gamma::Vector{Float64}: gamma, a learnabele parameter for each channel, initialized with ones\nweight_beta::Vector{Float64}: beta, a learnabele parameter for each channel, initialized with zeros\n\nGradients of weights (used if affine::Bool=true)\n\ngradient_gamma::Vector{Float64}: the gradients of gamma\ngradient_beta::Vector{Float64}: the gradients of beta\n\nRunning statistics (used if rack_running_stats::Bool=true)\n\nrunning_mean::Vector{Float64}: the continuously updated batch statistics of the mean\nrunning_variance::Vector{Float64}: the continuously updated batch statistics of the variance\n\nDefinition\n\nA batch normalization operation can be described as: For input values over a mini-batch: mathcalB = x_1 x_2  x_n\n\nbeginalign*\ny_i = fracx_i - overlinemathcalBsqrtVar(mathcalB) + epsilon cdot gamma + beta\nendalign*\n\nWhere y_i is an output value and x_i an input value. overlinemathcalB is the mean of the input values in mathcalB and Var(mathcalB)  is the variance of the input values in mathcalB. Note that this definition is fairly general and not specified to 4D inputs. In this case, the input values of mathcalB are taken for each channel individually.  So the mean and variance are calculated per channel over the mini-batch.\n\nThe update rule for the running statistics (running mean/variance) is:\n\nbeginalign*\nhatx_new = (1 - momentum) cdot hatx + momentum cdot x\nendalign*\n\nWhere hatx is the estimated statistic and x is the new observed value. So hatx_new is the new, updated estimated statistic.\n\nExamples\n\n# a batch normalization layer (3 channels) with learnabel parameters and continuously updated batch statistics for evaluation\njulia> m = BatchNorm2d(3)\n# the mode can be switched with trainmode! or testmode!\njulia> trainmode!(m)\njulia> testmode!(m)\n# computing the output of the layer (with random inputs)\njulia> input = rand(32, 1, 28, 28)\njulia> output = forward(m, input)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Reshape-/-Flatten","page":"Reference","title":"Reshape / Flatten","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Reshape","category":"page"},{"location":"reference/#GradValley.Layers.Reshape","page":"Reference","title":"GradValley.Layers.Reshape","text":"Reshape(out_shape; activation_function::Union{Nothing, String}=nothing)\n\nA reshape layer (probably mostly used as a flatten layer). Reshape the input signal (effects all dimensions except the batch dimension). This layer currently (!) only accepts Float64 array inputs. \n\nArguments\n\nout_shape: the target output size (the output has the same data as the input and must have the same number of elements)\nactivation_function::Union{Nothing, String}=nothing: the element-wise activation function which will be applied to the output\n\nShapes\n\nInput: (N *), where * means any number of dimensions\nOutput: (N out_shape)\n\nDefinition\n\nThis layer uses the standard reshape function inbuilt in Julia.\n\nExamples\n\n# flatten the input of size 1*28*28 to a vector of length 784 (each plus batch dimension of course)\njulia> m = Reshape((784, ))\n# computing the output of the layer (with random inputs)\njulia> input = rand(32, 1, 28, 28)\njulia> output = forward(m, input)\n\n\n\n\n\n","category":"type"},{"location":"reference/#Special-activation-functions","page":"Reference","title":"Special activation functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Softmax","category":"page"},{"location":"reference/#GradValley.Layers.Softmax","page":"Reference","title":"GradValley.Layers.Softmax","text":"Softmax(; dim::Integer=1)\n\nA softmax activation function layer (probably mostly used at the \"end\" of a classifier model). Apply the softmax function to an n-dimensional input array. The softmax will be computed along the given dimension (dim::Integer), so every slice along that dimension will sum to 1. This layer currently (!) only accepts Float64 array inputs. \n\nnote: Note\nNote that this is the only activation function in form of a layer. All other activation functions can be used with the activation_function::String keyword argument nearly every layer provides. All the activation functions which can be used that way are simple element-wise activation functions. Softmax is currently the only non-element-wise activation function. Besides it is very important to be able to select a specific dimension along the  softmax should be computed. That would also not work well with the use of simple keyword argument taking only a string which is the name of the function.\n\nArguments\n\ndim::Integer=1: the dimension along the softmax will be computed (so every slice along that dimension will sum to 1)\n\nShapes\n\nInput: (*), where * means any number of dimensions\nOutput: (*) (same shape as input)\n\nDefinition\n\nThe softmax function converts a vector of real numbers into a probability distribution. The softmax function is defined as:\n\nbeginalign*\nsoftmax(x_i) = frace^x_isum_je^x_j = fracexp(x_i)sum_jexp(x_j)\nendalign*\n\nWhere X is the input array (slice). Note that the x_j values are taken from each slice individually along the specified dimension. So each slice along the specified dimension will sum to 1. All values in the output are between 0 and 1.\n\nExamples\n\n# the softmax will be computed along the second dimension\njulia> m = Softmax(dim=2)\n# computing the output of the layer \n# (with random input data which could represent a batch of unnormalized output values from a classifier)\njulia> input = rand(32, 10)\njulia> output = forward(m, input)\n# summing up the values in the output along the second dimension result in a batch of 32 ones\njulia> sum(output, dims=2)\n32x1 Matrix{Float64}:\n1.0\n1.0\n...\n1.0\n\n\n\n\n\n","category":"type"},{"location":"reference/#GradValley.Optimization","page":"Reference","title":"GradValley.Optimization","text":"","category":"section"},{"location":"reference/#GradValley.Functional","page":"Reference","title":"GradValley.Functional","text":"","category":"section"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the GradValley.jl documentation!","category":"page"},{"location":"","page":"Home","title":"Home","text":"GradValley.jl is a new lightweight module for deep learning written in 100% Julia. It offers a high level interface for model building and training. It is completely independent from other machine learning packages like Flux, Knet, NNlib or NNPACK. It is based on Julia's standard array type and needs no additional tensor type. GradValley.jl's \"backend\" is written \"human-friendly\". So if you're looking into how exactly such deep learning algorithms work, looking at the source code could also be a good learning resource. See Learning for further information. To get started, see Installation and Getting Started. After that, you could look at the Tutorials and Examples section.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThis software package and its documentation are in an early stage of development and are therefore still a beta version. If you are missing certain features, see Current Limitations for planned future features, or directly share your ideas in the discussion section of the GitHub repository.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThis documentation is currently under construction. It currently does not claim to be complete, it is clear that some entries and information are still missing. It is currently being continuously adapted and improved.","category":"page"},{"location":"#About","page":"Home","title":"About","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A while ago I started looking into machine learning. The topic fascinated me from the beginning, so I wanted to gain a deeper understanding of the way such models work. In my opinion, the best way to do this is to write your own small software package for machine learning and not just blindly use one of the big, established frameworks such as PyTorch or TensorFlow. The Julia programming language was my choice because of its popularity in academia and its very good performance compared to pure Python, which is after all very popular in the world of artificial intelligence. The product of this work is this module called GradValley.jl with which various current neural networks (e.g. CNNs) can be implemented easily and intuitively.","category":"page"},{"location":"#Array-structure-convention:","page":"Home","title":"Array structure convention:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The order used in GradValley for processing images (or similar data) is NCHW, where N is the batch dimension, C is the channel dimension, H is the vertical and W is the horizontal size of the image. In this regard, GradValley differs from some other deep learning packages in Julia and is similar to PyTorch instead. This makes the migration of pre-trained models from PyTorch or from the Python world in general to GradValley much easier.","category":"page"},{"location":"#Explanation-of-the-name-\"GradValley\":","page":"Home","title":"Explanation of the name \"GradValley\":","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"When optimizing the weights of a machine learning model, an attempt is always made to find the best possible error minimum. The derivatives, i.e. the gradients, of the error function in relation to the weights are required for this. So the goal is to find the \"valley\" of the error using the gradients (\"grad\" stands for gradient). That's why it's called GradValley.","category":"page"},{"location":"#Current-Limitations","page":"Home","title":"Current Limitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Due to the relatively early development status of this software, no GPU support is currently offered.  The following features are planned and likely to be added in the future:","category":"page"},{"location":"","page":"Home","title":"Home","text":"more predefined activation function, loss functions and optimizers","category":"page"},{"location":"#GitHub-Repository","page":"Home","title":"GitHub Repository","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the GitHub repository of GradValley.jl, you can find e.g. the source code, the source of this documentation and information about continues testing and it's code coverage. The repo is also the place to ask questions and share your thoughts about this project. Contributing or opening issues is of course also welcome. (This documentation page is also hosted on GitHub using GitHub Pages.)","category":"page"},{"location":"#Questions-and-Discussions","page":"Home","title":"Questions and Discussions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have any questions about this software package, please let me know in the discussion section of the GitHub repository.","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Everyone is invited to contribute. To do so:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fork the current-most state of the main branch\nImplement features or changes\nAdd your name to AUTHORS.md\nCreate a pull-request to the upstream repository","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The GradValley.jl software package is currently published under the MIT \"Expat\" license. See LICENSE in the GitHub repository for further information.","category":"page"}]
}
